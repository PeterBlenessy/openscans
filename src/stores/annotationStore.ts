import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { Annotation } from '@/types/annotation'
import { useSettingsStore } from './settingsStore'

interface AnnotationState {
  annotations: Annotation[] // Flat array like favorites
  selectedAnnotationId: string | null
  isLoading: boolean

  // Actions
  setAnnotations: (annotations: Annotation[]) => void
  addAnnotation: (annotation: Annotation) => void
  addAnnotations: (annotations: Annotation[]) => void
  updateAnnotation: (id: string, updates: Partial<Annotation>) => void
  deleteAnnotation: (id: string) => void
  deleteAnnotationsForInstance: (sopInstanceUID: string, autoGeneratedOnly?: boolean) => void
  selectAnnotation: (id: string | null) => void
  getAnnotationsForInstance: (sopInstanceUID: string) => Annotation[]
  setLoading: (loading: boolean) => void
  reset: () => void
}

const initialState = {
  annotations: [],
  selectedAnnotationId: null,
  isLoading: false,
}

export const useAnnotationStore = create<AnnotationState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setAnnotations: (annotations) => set({ annotations }),

      addAnnotation: (annotation) => {
        // Preserve original position for AI-generated markers
        const annotationWithOriginal = annotation.type === 'marker' && annotation.autoGenerated && !annotation.originalPosition
          ? {
              ...annotation,
              originalPosition: { ...annotation.position },
              manuallyAdjusted: false
            }
          : annotation

        set((state) => ({
          annotations: [...state.annotations, annotationWithOriginal],
        }))
      },

      addAnnotations: (annotations) => {
        // Preserve original position for AI-generated markers
        const annotationsWithOriginal = annotations.map(ann => {
          if (ann.type === 'marker' && ann.autoGenerated && !ann.originalPosition) {
            return {
              ...ann,
              originalPosition: { ...ann.position },
              manuallyAdjusted: false
            }
          }
          return ann
        })

        set((state) => ({
          annotations: [...state.annotations, ...annotationsWithOriginal],
        }))
      },

      updateAnnotation: (id, updates) =>
        set((state) => ({
          annotations: state.annotations.map((ann) => {
            if (ann.id === id) {
              // If position changed, mark as manually adjusted
              if ('position' in updates && ann.type === 'marker') {
                return {
                  ...ann,
                  ...updates,
                  manuallyAdjusted: true
                } as Annotation
              }
              return { ...ann, ...updates } as Annotation
            }
            return ann
          }),
        })),

      deleteAnnotation: (id) =>
        set((state) => ({
          annotations: state.annotations.filter((ann) => ann.id !== id),
        })),

      deleteAnnotationsForInstance: (sopInstanceUID, autoGeneratedOnly = false) =>
        set((state) => ({
          annotations: state.annotations.filter((ann) => {
            if (ann.sopInstanceUID !== sopInstanceUID) return true
            if (autoGeneratedOnly && !ann.autoGenerated) return true
            return false
          }),
        })),

      selectAnnotation: (id) => set({ selectedAnnotationId: id }),

      getAnnotationsForInstance: (sopInstanceUID) => {
        return get().annotations.filter(
          (ann) => ann.sopInstanceUID === sopInstanceUID
        )
      },

      setLoading: (loading) => set({ isLoading: loading }),

      reset: () => set(initialState),
    }),
    {
      name: 'openscans-annotations',
      version: 1,
      partialize: (state) => ({
        annotations: state.annotations, // Only persist the annotations array, not UI state
      }),
    }
  )
)
