import { useEffect, useState, useMemo } from 'react'
import { useAnnotationStore } from '@/stores/annotationStore'
import { useViewportStore } from '@/stores/viewportStore'
import { useStudyStore } from '@/stores/studyStore'
import { MarkerAnnotation } from '@/types/annotation'
import { annotationColors } from '@/lib/colors'
// @ts-expect-error - cornerstone-core doesn't have TypeScript definitions
import cornerstone from 'cornerstone-core'

interface AnnotationOverlayProps {
  canvasElement: HTMLDivElement | null
}

export function AnnotationOverlay({ canvasElement }: AnnotationOverlayProps) {
  const [dimensions, setDimensions] = useState({ width: 0, height: 0 })
  const showAnnotations = useViewportStore((state) => state.showAnnotations)
  const currentInstance = useStudyStore((state) => state.currentInstance)
  const allAnnotations = useAnnotationStore((state) => state.annotations)
  const areMarkersVisible = useAnnotationStore((state) =>
    currentInstance ? state.areMarkersVisible(currentInstance.sopInstanceUID) : true
  )

  // Track canvas dimensions
  useEffect(() => {
    if (!canvasElement) return

    const updateDimensions = () => {
      const rect = canvasElement.getBoundingClientRect()
      setDimensions({ width: rect.width, height: rect.height })
    }

    // Initial dimensions
    updateDimensions()

    // Watch for resize
    const resizeObserver = new ResizeObserver(updateDimensions)
    resizeObserver.observe(canvasElement)

    return () => {
      resizeObserver.disconnect()
    }
  }, [canvasElement])

  // Get annotations for current instance (only if markers are visible)
  const annotations = useMemo(() => {
    if (!currentInstance || !showAnnotations || !areMarkersVisible) return []
    return allAnnotations.filter((ann) => ann.sopInstanceUID === currentInstance.sopInstanceUID)
  }, [currentInstance, showAnnotations, areMarkersVisible, allAnnotations])


  if (!canvasElement || !currentInstance || !showAnnotations || annotations.length === 0) {
    return null
  }

  // Wait for dimensions to be set by ResizeObserver
  if (dimensions.width === 0 || dimensions.height === 0) {
    return null
  }

  return (
    <svg
      className="absolute inset-0"
      width={dimensions.width}
      height={dimensions.height}
      style={{ zIndex: 10, pointerEvents: 'none' }}
    >
      {annotations.map((annotation) => {
        if (annotation.type === 'marker') {
          return (
            <MarkerRenderer
              key={annotation.id}
              annotation={annotation}
              canvasElement={canvasElement}
            />
          )
        }
        return null
      })}
    </svg>
  )
}

interface MarkerRendererProps {
  annotation: MarkerAnnotation
  canvasElement: HTMLDivElement
}

function MarkerRenderer({ annotation, canvasElement }: MarkerRendererProps) {
  const [isDragging, setIsDragging] = useState(false)
  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
  const [showContextMenu, setShowContextMenu] = useState(false)
  const [contextMenuPos, setContextMenuPos] = useState({ x: 0, y: 0 })
  const updateAnnotation = useAnnotationStore((state) => state.updateAnnotation)
  const deleteAnnotationsForInstance = useAnnotationStore((state) => state.deleteAnnotationsForInstance)
  const currentInstance = useStudyStore((state) => state.currentInstance)
  const allAnnotations = useAnnotationStore((state) => state.annotations)

  // Check if there are any AI markers in the current instance
  const hasAiMarkers = currentInstance
    ? allAnnotations.some(a =>
        a.sopInstanceUID === currentInstance.sopInstanceUID &&
        a.type === 'marker' &&
        a.autoGenerated
      )
    : false

  // Close context menu when clicking elsewhere
  useEffect(() => {
    if (!showContextMenu) return

    const handleClick = () => setShowContextMenu(false)
    document.addEventListener('click', handleClick)
    return () => document.removeEventListener('click', handleClick)
  }, [showContextMenu])

  // Check if an image is loaded before trying to convert coordinates
  let hasImage = false
  try {
    const image = cornerstone.getImage(canvasElement)
    hasImage = !!image
  } catch (err) {
    hasImage = false
  }

  if (!hasImage) {
    return null // No image loaded yet
  }

  // Convert image pixel coordinates to canvas coordinates using Cornerstone
  // This properly handles viewport transformations (scale, translation, rotation)
  const imageCoords = { x: annotation.position.x, y: annotation.position.y }
  const canvasCoords = cornerstone.pixelToCanvas(canvasElement, imageCoords)

  const viewportX = canvasCoords.x + dragOffset.x
  const viewportY = canvasCoords.y + dragOffset.y

  const radius = 8
  const labelOffsetX = 12
  const labelOffsetY = 5

  // Use orange for all markers
  const markerColor = annotationColors.orange
  // Fill opacity: solid when manually adjusted, transparent when automatic
  const fillOpacity = annotation.manuallyAdjusted ? 0.8 : 0.15
  const strokeWidth = 1.5

  const handleMouseDown = (e: React.MouseEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setIsDragging(true)
  }

  const handleMouseMove = (e: React.MouseEvent) => {
    if (!isDragging) return

    setDragOffset({
      x: dragOffset.x + e.movementX,
      y: dragOffset.y + e.movementY
    })
  }

  const handleMouseUp = () => {
    if (!isDragging) return

    // Convert final canvas position back to image coordinates
    const finalCanvasX = canvasCoords.x + dragOffset.x
    const finalCanvasY = canvasCoords.y + dragOffset.y
    const finalImageCoords = cornerstone.canvasToPixel(canvasElement, { x: finalCanvasX, y: finalCanvasY })

    const deltaX = finalImageCoords.x - annotation.position.x
    const deltaY = finalImageCoords.y - annotation.position.y

    // Only update if there was actual movement (> 0.5px threshold to avoid floating point errors)
    if (Math.abs(deltaX) > 0.5 || Math.abs(deltaY) > 0.5) {
      console.log(`[AnnotationOverlay] ${annotation.label} adjusted: (${deltaX.toFixed(1)}, ${deltaY.toFixed(1)})px`)

      // Update the annotation with corrected position
      updateAnnotation(annotation.id, {
        position: {
          x: finalImageCoords.x,
          y: finalImageCoords.y
        }
      })
    }

    setIsDragging(false)
    setDragOffset({ x: 0, y: 0 })
  }

  const handleContextMenu = (e: React.MouseEvent) => {
    // Only show context menu if there are AI markers
    if (!hasAiMarkers) return

    e.preventDefault()
    e.stopPropagation()

    // Get SVG element to calculate proper coordinates
    const svgElement = (e.target as SVGElement).ownerSVGElement
    if (!svgElement) return

    const rect = svgElement.getBoundingClientRect()
    setContextMenuPos({
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    })
    setShowContextMenu(true)
  }

  const handleDeleteAllAiMarkers = () => {
    if (!currentInstance) return
    deleteAnnotationsForInstance(currentInstance.sopInstanceUID, true) // Only delete AI-generated
    setShowContextMenu(false)
  }

  return (
    <>
    <g
      onMouseDown={handleMouseDown}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
      onContextMenu={handleContextMenu}
      style={{ cursor: isDragging ? 'grabbing' : 'grab', pointerEvents: 'all' }}
    >
      {/* Marker circle */}
      <circle
        cx={viewportX}
        cy={viewportY}
        r={radius}
        fill={markerColor}
        fillOpacity={fillOpacity}
        stroke={markerColor}
        strokeWidth={strokeWidth}
      />

      {/* Label */}
      {annotation.label && (
        <text
          x={viewportX + labelOffsetX}
          y={viewportY + labelOffsetY}
          fill={markerColor}
          fontSize="12px"
          fontWeight="bold"
          fontFamily="sans-serif"
          style={{ pointerEvents: 'none', userSelect: 'none' }}
        >
          {annotation.label}
        </text>
      )}
    </g>

    {/* Context menu */}
    {showContextMenu && hasAiMarkers && (
      <foreignObject
        x={contextMenuPos.x}
        y={contextMenuPos.y}
        width="180"
        height="40"
        style={{ overflow: 'visible' }}
      >
        <div
          className="bg-[#1a1a1a] border border-[#3a3a3a] rounded shadow-lg py-1"
          style={{ pointerEvents: 'all' }}
        >
          <button
            onClick={handleDeleteAllAiMarkers}
            className="w-full px-3 py-1.5 text-left text-sm text-red-400 hover:bg-[#2a2a2a] transition-colors flex items-center gap-2"
          >
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" className="w-4 h-4">
              <path fillRule="evenodd" d="M8.75 1A2.75 2.75 0 006 3.75v.443c-.795.077-1.584.176-2.365.298a.75.75 0 10.23 1.482l.149-.022.841 10.518A2.75 2.75 0 007.596 19h4.807a2.75 2.75 0 002.742-2.53l.841-10.52.149.023a.75.75 0 00.23-1.482A41.03 41.03 0 0014 4.193V3.75A2.75 2.75 0 0011.25 1h-2.5zM10 4c.84 0 1.673.025 2.5.075V3.75c0-.69-.56-1.25-1.25-1.25h-2.5c-.69 0-1.25.56-1.25 1.25v.325C8.327 4.025 9.16 4 10 4zM8.58 7.72a.75.75 0 00-1.5.06l.3 7.5a.75.75 0 101.5-.06l-.3-7.5zm4.34.06a.75.75 0 10-1.5-.06l-.3 7.5a.75.75 0 101.5.06l.3-7.5z" clipRule="evenodd" />
            </svg>
            Delete AI markers
          </button>
        </div>
      </foreignObject>
    )}
    </>
  )
}
