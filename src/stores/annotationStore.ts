import { create } from 'zustand'
import { persist } from 'zustand/middleware'
import { Annotation } from '@/types/annotation'
import { useSettingsStore } from './settingsStore'

/**
 * Annotation store state interface.
 *
 * Manages all types of annotations (markers, measurements, regions) and their visibility.
 * Annotations are persisted to localStorage and survive page refreshes.
 *
 * Key features:
 * - Flat array storage (like favorites pattern)
 * - Per-instance marker visibility toggle
 * - Automatic originalPosition tracking for AI-generated markers
 * - Selection state for annotation editing
 */
interface AnnotationState {
  /** All annotations across all instances (flat array) */
  annotations: Annotation[]
  /** ID of currently selected annotation for editing/highlighting */
  selectedAnnotationId: string | null
  /** Whether annotations are being loaded */
  isLoading: boolean
  /** Set of sopInstanceUIDs where markers are hidden (all other instances show markers) */
  hiddenMarkerInstances: Set<string>

  // Actions
  /** Replace all annotations */
  setAnnotations: (annotations: Annotation[]) => void
  /** Add a single annotation (preserves originalPosition for AI markers) */
  addAnnotation: (annotation: Annotation) => void
  /** Add multiple annotations (preserves originalPosition for AI markers) */
  addAnnotations: (annotations: Annotation[]) => void
  /** Update an annotation (marks as manuallyAdjusted if position changed) */
  updateAnnotation: (id: string, updates: Partial<Annotation>) => void
  /** Delete a single annotation by ID */
  deleteAnnotation: (id: string) => void
  /** Delete all annotations for an instance (optionally only AI-generated ones) */
  deleteAnnotationsForInstance: (sopInstanceUID: string, autoGeneratedOnly?: boolean) => void
  /** Select an annotation for editing */
  selectAnnotation: (id: string | null) => void
  /** Get all annotations for a specific instance */
  getAnnotationsForInstance: (sopInstanceUID: string) => Annotation[]
  /** Toggle marker visibility for a specific instance */
  toggleMarkerVisibility: (sopInstanceUID: string) => void
  /** Check if markers are visible for a specific instance */
  areMarkersVisible: (sopInstanceUID: string) => boolean
  /** Set loading state */
  setLoading: (loading: boolean) => void
  /** Reset store to initial state (clears all annotations) */
  reset: () => void
}

const initialState = {
  annotations: [],
  selectedAnnotationId: null,
  isLoading: false,
  hiddenMarkerInstances: new Set<string>(),
}

/**
 * Zustand store for managing DICOM image annotations.
 *
 * Annotations are persisted to localStorage under 'openscans-annotations'.
 * Only the annotations array is persisted; UI state (selection, loading) is reset on reload.
 *
 * Special handling for AI-generated markers:
 * - originalPosition is automatically preserved when adding new AI markers
 * - manuallyAdjusted flag is set when user moves an AI marker
 *
 * @example
 * ```tsx
 * // Select state
 * const annotations = useAnnotationStore((state) => state.annotations)
 * const currentAnnotations = useAnnotationStore((state) =>
 *   state.getAnnotationsForInstance(instanceUID)
 * )
 *
 * // Call actions
 * const { addAnnotation, deleteAnnotation } = useAnnotationStore()
 * addAnnotation(newMarker)
 * deleteAnnotation('marker-id')
 * ```
 *
 * @example
 * ```tsx
 * // Working with AI annotations
 * const { addAnnotations, deleteAnnotationsForInstance } = useAnnotationStore()
 *
 * // Add AI detection results (originalPosition automatically preserved)
 * addAnnotations(aiMarkers)
 *
 * // Clear only AI annotations before re-running detection
 * deleteAnnotationsForInstance(instanceUID, true) // autoGeneratedOnly=true
 * ```
 */
export const useAnnotationStore = create<AnnotationState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setAnnotations: (annotations) => set({ annotations }),

      /**
       * Add a single annotation to the store.
       *
       * For AI-generated markers without an originalPosition, this function automatically:
       * 1. Preserves the current position as originalPosition
       * 2. Sets manuallyAdjusted to false
       *
       * This allows tracking if the user later moves the marker.
       *
       * @param annotation - The annotation to add
       *
       * @example
       * ```ts
       * // Add manual marker
       * addAnnotation({
       *   id: 'manual-1',
       *   type: 'marker',
       *   position: { x: 256, y: 256 },
       *   label: 'Finding',
       *   autoGenerated: false,
       *   // ... other fields
       * })
       *
       * // Add AI marker (originalPosition auto-preserved)
       * addAnnotation(aiMarker)
       * ```
       */
      addAnnotation: (annotation) => {
        // Preserve original position for AI-generated markers
        const annotationWithOriginal = annotation.type === 'marker' && annotation.autoGenerated && !annotation.originalPosition
          ? {
              ...annotation,
              originalPosition: { ...annotation.position },
              manuallyAdjusted: false
            }
          : annotation

        set((state) => ({
          annotations: [...state.annotations, annotationWithOriginal],
        }))
      },

      /**
       * Add multiple annotations to the store in a single operation.
       *
       * For AI-generated markers without originalPosition, this function automatically:
       * 1. Preserves the current position as originalPosition
       * 2. Sets manuallyAdjusted to false
       *
       * More efficient than calling addAnnotation multiple times.
       *
       * @param annotations - Array of annotations to add
       *
       * @example
       * ```ts
       * // Add AI detection results
       * const aiMarkers = await detector.detectVertebrae(instance)
       * addAnnotations(aiMarkers)
       * ```
       */
      addAnnotations: (annotations) => {
        // Preserve original position for AI-generated markers
        const annotationsWithOriginal = annotations.map(ann => {
          if (ann.type === 'marker' && ann.autoGenerated && !ann.originalPosition) {
            return {
              ...ann,
              originalPosition: { ...ann.position },
              manuallyAdjusted: false
            }
          }
          return ann
        })

        set((state) => ({
          annotations: [...state.annotations, ...annotationsWithOriginal],
        }))
      },

      /**
       * Update an existing annotation by ID.
       *
       * Special handling for marker position changes:
       * - If updating a marker's position, automatically sets manuallyAdjusted=true
       * - This allows distinguishing user-adjusted AI markers from untouched ones
       *
       * @param id - The annotation ID to update
       * @param updates - Partial annotation fields to update
       *
       * @example
       * ```ts
       * // Update marker label
       * updateAnnotation('marker-1', { label: 'L1-L2' })
       *
       * // Move marker (automatically marks as manuallyAdjusted)
       * updateAnnotation('ai-marker-1', { position: { x: 260, y: 150 } })
       *
       * // Update severity
       * updateAnnotation('marker-2', { severity: 'abnormal' })
       * ```
       */
      updateAnnotation: (id, updates) =>
        set((state) => ({
          annotations: state.annotations.map((ann) => {
            if (ann.id === id) {
              // If position changed, mark as manually adjusted
              if ('position' in updates && ann.type === 'marker') {
                return {
                  ...ann,
                  ...updates,
                  manuallyAdjusted: true
                } as Annotation
              }
              return { ...ann, ...updates } as Annotation
            }
            return ann
          }),
        })),

      /**
       * Delete a single annotation by ID.
       *
       * @param id - The annotation ID to delete
       */
      deleteAnnotation: (id) =>
        set((state) => ({
          annotations: state.annotations.filter((ann) => ann.id !== id),
        })),

      /**
       * Delete all annotations for a specific instance.
       *
       * This is commonly used when:
       * - Clearing AI annotations before re-running detection (autoGeneratedOnly=true)
       * - Removing all annotations when closing an instance (autoGeneratedOnly=false)
       *
       * @param sopInstanceUID - The instance UID to clear annotations for
       * @param autoGeneratedOnly - If true, only delete AI-generated annotations (default: false)
       *
       * @example
       * ```ts
       * // Clear only AI annotations before re-detection
       * deleteAnnotationsForInstance(instanceUID, true)
       *
       * // Clear all annotations for an instance
       * deleteAnnotationsForInstance(instanceUID, false)
       * ```
       */
      deleteAnnotationsForInstance: (sopInstanceUID, autoGeneratedOnly = false) =>
        set((state) => ({
          annotations: state.annotations.filter((ann) => {
            if (ann.sopInstanceUID !== sopInstanceUID) return true
            if (autoGeneratedOnly && !ann.autoGenerated) return true
            return false
          }),
        })),

      selectAnnotation: (id) => set({ selectedAnnotationId: id }),

      getAnnotationsForInstance: (sopInstanceUID) => {
        return get().annotations.filter(
          (ann) => ann.sopInstanceUID === sopInstanceUID
        )
      },

      toggleMarkerVisibility: (sopInstanceUID) => {
        set((state) => {
          const newHidden = new Set(state.hiddenMarkerInstances)
          if (newHidden.has(sopInstanceUID)) {
            newHidden.delete(sopInstanceUID)
          } else {
            newHidden.add(sopInstanceUID)
          }
          return { hiddenMarkerInstances: newHidden }
        })
      },

      areMarkersVisible: (sopInstanceUID) => {
        return !get().hiddenMarkerInstances.has(sopInstanceUID)
      },

      setLoading: (loading) => set({ isLoading: loading }),

      reset: () => set(initialState),
    }),
    {
      name: 'openscans-annotations',
      version: 1,
      partialize: (state) => ({
        annotations: state.annotations, // Only persist the annotations array, not UI state
      }),
    }
  )
)
