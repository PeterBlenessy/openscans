import { DicomInstance } from '@/types'
/* eslint-disable @typescript-eslint/no-explicit-any */
import { MarkerAnnotation } from '@/types/annotation'
import { DetectionResult, AnalysisResult, VisionDetector, VertebraResponse } from './types'
import { AiAnalysis } from '@/stores/aiAnalysisStore'
import { dicomToBase64Png } from './dicomImageUtils'
import { parseApiError } from './errorHandler'
import { useSettingsStore } from '@/stores/settingsStore'

/**
 * Abstract base class for AI vision detectors.
 * Consolidates common logic across Claude, Gemini, and OpenAI implementations.
 *
 * Subclasses must implement:
 * - getName(): Provider name for logging and error messages
 * - getModelVersion(): Model identifier for annotation metadata
 * - initializeClient(apiKey): Create provider-specific API client
 * - callDetectionAPI(imageData, dims): Call provider's vision API for vertebra detection
 * - callAnalysisAPI(imageData, language): Call provider's vision API for general analysis
 * - parseDetectionResponse(response): Extract VertebraResponse from provider's response format
 * - parseAnalysisResponse(response): Extract analysis text from provider's response format
 *
 * Common functionality provided:
 * - API key management
 * - Configuration checking
 * - Image conversion (DICOM to base64 PNG)
 * - Performance timing
 * - Annotation creation
 * - Error handling
 * - Logging
 */
export abstract class BaseVisionDetector implements VisionDetector {
  protected apiKey: string | null = null
  protected client: any = null

  /**
   * Set API key and initialize the provider-specific client
   */
  setApiKey(apiKey: string): void {
    this.apiKey = apiKey
    this.initializeClient(apiKey)
  }

  /**
   * Check if detector is configured with API key
   */
  isConfigured(): boolean {
    return this.apiKey !== null && this.client !== null
  }

  /**
   * Detect vertebrae using the AI vision provider.
   * Handles common workflow: validation, image conversion, API call, annotation creation.
   */
  async detectVertebrae(instance: DicomInstance): Promise<DetectionResult> {
    const startTime = performance.now()

    if (!this.isConfigured()) {
      throw new Error(
        `${this.getName()} detector not configured. Please set API key in settings.`
      )
    }

    try {
      // Convert DICOM to base64 PNG and get dimensions
      const { data: imageData, imageColumns, imageRows } = await dicomToBase64Png()

      // Call provider-specific API
      const response = await this.callDetectionAPI(imageData, { imageColumns, imageRows })

      // Parse provider-specific response format
      const vertebraResponse = this.parseDetectionResponse(response)

      // Create standardized annotations
      const annotations: MarkerAnnotation[] = vertebraResponse.vertebrae.map(
        (vertebra, index) => ({
          id: `ai-${this.getName().toLowerCase()}-${instance.sopInstanceUID}-${vertebra.label}-${Date.now()}-${index}`,
          type: 'marker',
          seriesInstanceUID: instance.metadata?.seriesDescription || '',
          sopInstanceUID: instance.sopInstanceUID,
          instanceNumber: instance.instanceNumber,
          severity: 'normal',
          description: `AI-detected ${vertebra.label} vertebra (confidence: ${(vertebra.confidence * 100).toFixed(1)}%)`,
          createdAt: new Date().toISOString(),
          createdBy: this.getModelVersion(),
          autoGenerated: true,
          modelVersion: this.getModelVersion(),
          position: {
            x: vertebra.position.x,
            y: vertebra.position.y,
          },
          label: vertebra.label,
        })
      )

      // Calculate average confidence
      const avgConfidence =
        vertebraResponse.vertebrae.length > 0
          ? vertebraResponse.vertebrae.reduce((sum, v) => sum + v.confidence, 0) /
            vertebraResponse.vertebrae.length
          : 0

      const processingTimeMs = performance.now() - startTime

      console.log(
        `[${this.getName()}Detector] Detected ${annotations.length} vertebrae in ${processingTimeMs.toFixed(0)}ms`
      )

      return {
        annotations,
        confidence: avgConfidence,
        processingTimeMs,
      }
    } catch (error) {
      const errorDetails = parseApiError(error, this.getName().toLowerCase() as 'claude' | 'gemini' | 'openai')
      console.error(`[${this.getName()}Detector] Detection failed:`, errorDetails.message)

      // Create a user-friendly error
      const userError = new Error(errorDetails.userMessage)
      // Attach error details for debugging
      ;(userError as any).details = errorDetails
      throw userError
    }
  }

  /**
   * Perform generic radiology analysis using the AI vision provider.
   * Returns a comprehensive analysis of the medical image.
   */
  async analyzeImage(instance: DicomInstance): Promise<AnalysisResult> {
    const startTime = performance.now()

    if (!this.isConfigured()) {
      throw new Error(
        `${this.getName()} detector not configured. Please set API key in settings.`
      )
    }

    try {
      // Convert DICOM to base64 PNG
      const { data: imageData } = await dicomToBase64Png()

      // Get language preference from settings
      const language = useSettingsStore.getState().aiResponseLanguage || 'English'

      // Call provider-specific API
      const response = await this.callAnalysisAPI(imageData, language)

      // Parse provider-specific response format
      const analysisText = this.parseAnalysisResponse(response)

      if (!analysisText || analysisText.trim().length === 0) {
        throw new Error(`${this.getName()} returned an empty analysis`)
      }

      const analysis: AiAnalysis = {
        id: `ai-analysis-${instance.sopInstanceUID}-${Date.now()}`,
        sopInstanceUID: instance.sopInstanceUID,
        instanceNumber: instance.instanceNumber,
        findings: analysisText,
        createdAt: new Date().toISOString(),
        createdBy: this.getModelVersion(),
        modelVersion: this.getModelVersion(),
      }

      const processingTimeMs = performance.now() - startTime

      console.log(
        `[${this.getName()}Detector] Generated radiology analysis in ${processingTimeMs.toFixed(0)}ms`
      )

      return {
        analysis,
        processingTimeMs,
      }
    } catch (error) {
      const errorDetails = parseApiError(error, this.getName().toLowerCase() as 'claude' | 'gemini' | 'openai')
      console.error(`[${this.getName()}Detector] Analysis failed:`, errorDetails.message)

      // Create a user-friendly error
      const userError = new Error(errorDetails.userMessage)
      // Attach error details for debugging
      ;(userError as any).details = errorDetails
      throw userError
    }
  }

  // ========== Abstract methods that subclasses must implement ==========

  /**
   * Get the name of this detector (e.g., "Claude", "Gemini", "OpenAI")
   * Used for logging and error messages.
   */
  protected abstract getName(): string

  /**
   * Get the model version string for annotation metadata
   * (e.g., "claude-opus-4-5", "gemini-3-flash", "gpt-4o")
   */
  protected abstract getModelVersion(): string

  /**
   * Initialize the provider-specific API client with the given API key.
   * Should set this.client to the initialized client instance.
   */
  protected abstract initializeClient(apiKey: string): void

  /**
   * Call the provider's vision API for vertebra detection.
   *
   * @param imageData Base64-encoded PNG image data
   * @param dims Image dimensions {imageColumns, imageRows}
   * @returns Provider-specific API response object
   */
  protected abstract callDetectionAPI(
    imageData: string,
    dims: { imageColumns: number; imageRows: number }
  ): Promise<any>

  /**
   * Call the provider's vision API for general radiology analysis.
   *
   * @param imageData Base64-encoded PNG image data
   * @param language Target language for the analysis (e.g., "English", "Swedish")
   * @returns Provider-specific API response object
   */
  protected abstract callAnalysisAPI(imageData: string, language: string): Promise<any>

  /**
   * Parse the provider's detection API response to extract vertebra data.
   *
   * @param response Raw API response from the provider
   * @returns Standardized VertebraResponse object
   */
  protected abstract parseDetectionResponse(response: any): VertebraResponse

  /**
   * Parse the provider's analysis API response to extract the analysis text.
   *
   * @param response Raw API response from the provider
   * @returns Analysis text string
   */
  protected abstract parseAnalysisResponse(response: any): string
}
