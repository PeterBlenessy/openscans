/**
 * Unit tests for useAiOperations hook
 *
 * Tests AI detection and analysis operations including:
 * - AI detection workflow
 * - AI analysis workflow
 * - Error handling
 * - Loading states
 * - Annotation management
 */

import { describe, it, expect, beforeEach, vi } from 'vitest'
import { renderHook, act } from '@testing-library/react'
import { useAiOperations } from './useAiOperations'
import { createMockInstance } from '@/test/fixtures/dicomData'
import type { Annotation } from '@/types/annotation'

// Mock the AI detector
vi.mock('@/lib/ai/mockVertebralDetector', () => ({
  mockDetector: {
    detectVertebrae: vi.fn().mockResolvedValue({
      annotations: [
        {
          id: 'ann1',
          type: 'marker' as const,
          position: { x: 100, y: 100 },
          label: 'L1',
          severity: 'normal' as const,
          sopInstanceUID: 'test-instance-uid',
          autoGenerated: true,
        },
      ],
      confidence: 0.9,
      processingTimeMs: 500,
    }),
    analyzeImage: vi.fn().mockResolvedValue({
      analysis: {
        findings: 'Test findings',
        impression: 'Test impression',
      },
      processingTimeMs: 1000,
    }),
    isConfigured: vi.fn(() => true),
    setApiKey: vi.fn(),
  },
}))

// Mock the settings store
vi.mock('@/stores/settingsStore', () => ({
  useSettingsStore: {
    getState: () => ({
      aiEnabled: true,
      aiProvider: 'claude',
      aiApiKey: 'test-key',
    }),
  },
}))

// Mock the Claude detector
vi.mock('@/lib/ai/claudeVisionDetector', () => ({
  claudeDetector: {
    detectVertebrae: vi.fn().mockResolvedValue({
      annotations: [
        {
          id: 'ann1',
          type: 'marker' as const,
          position: { x: 100, y: 100 },
          label: 'L1',
          severity: 'normal' as const,
          sopInstanceUID: 'test-instance-uid',
          autoGenerated: true,
        },
      ],
      confidence: 0.9,
      processingTimeMs: 500,
    }),
    analyzeImage: vi.fn().mockResolvedValue({
      analysis: {
        findings: 'Test findings',
        impression: 'Test impression',
      },
      processingTimeMs: 1000,
    }),
    isConfigured: vi.fn(() => true),
    setApiKey: vi.fn(),
  },
}))

// Mock the AI detector manager
vi.mock('@/lib/ai/aiDetectorManager', () => ({
  initDetector: vi.fn(async (provider: string) => {
    if (provider === 'claude') {
      // Import the mocked claudeDetector
      const { claudeDetector } = await import('@/lib/ai/claudeVisionDetector')
      return claudeDetector
    }
    // Import the mocked mockDetector
    const { mockDetector } = await import('@/lib/ai/mockVertebralDetector')
    return mockDetector
  }),
  getApiKeyForProvider: vi.fn((provider: string, keys: any) => {
    return keys.aiApiKey || keys.geminiApiKey || keys.openaiApiKey || ''
  }),
}))

describe('useAiOperations', () => {
  const mockInstance = createMockInstance()
  const mockStudy = {
    studyInstanceUID: 'study-uid',
    patientName: 'Test Patient',
    patientID: '12345',
    studyDate: '20240101',
    studyDescription: 'Test Study',
    series: [],
  }
  const mockAddAnnotations = vi.fn()
  const mockDeleteAnnotationsForInstance = vi.fn()
  const mockAddAnalysis = vi.fn()
  const mockSetDetecting = vi.fn()
  const mockSetAnalyzing = vi.fn()
  const mockHandleError = vi.fn()

  const defaultOptions = {
    currentInstance: mockInstance,
    currentStudy: mockStudy,
    isDetecting: false,
    isAnalyzing: false,
    setDetecting: mockSetDetecting,
    setAnalyzing: mockSetAnalyzing,
    addAnnotations: mockAddAnnotations,
    deleteAnnotationsForInstance: mockDeleteAnnotationsForInstance,
    addAnalysis: mockAddAnalysis,
    handleError: mockHandleError,
  }

  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('handleAiDetection', () => {
    it('should not run if no current instance', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, currentInstance: null })
      )

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockSetDetecting).not.toHaveBeenCalled()
    })

    it('should not run if already detecting', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, isDetecting: true })
      )

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockDeleteAnnotationsForInstance).not.toHaveBeenCalled()
    })

    it('should delete existing auto-annotations before detection', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockDeleteAnnotationsForInstance).toHaveBeenCalledWith(
        mockInstance.sopInstanceUID,
        true // autoOnly = true
      )
    })

    it('should set detecting state to true', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockSetDetecting).toHaveBeenCalledWith(true)
    })

    it('should add annotations on successful detection', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockAddAnnotations).toHaveBeenCalled()
      const annotations = mockAddAnnotations.mock.calls[0][0] as Annotation[]
      expect(annotations).toHaveLength(1)
      expect(annotations[0].type).toBe('marker')
    })

    it('should set detecting to false on success', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiDetection()
      })

      // Should be called twice: true to start, false to end
      expect(mockSetDetecting).toHaveBeenCalledTimes(2)
      expect(mockSetDetecting).toHaveBeenLastCalledWith(false)
    })

    it('should handle detection errors', async () => {
      const { claudeDetector } = await import('@/lib/ai/claudeVisionDetector')
      vi.mocked(claudeDetector.detectVertebrae).mockRejectedValueOnce(
        new Error('Detection failed')
      )

      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiDetection()
      })

      expect(mockSetDetecting).toHaveBeenCalledWith(
        false,
        'Detection failed'
      )
    })
  })

  describe('handleAiAnalysis', () => {
    it('should not run if no current instance', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, currentInstance: null })
      )

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      expect(mockSetAnalyzing).not.toHaveBeenCalled()
    })

    it('should not run if already analyzing', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, isAnalyzing: true })
      )

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      expect(mockAddAnalysis).not.toHaveBeenCalled()
    })

    it('should set analyzing state to true', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      expect(mockSetAnalyzing).toHaveBeenCalledWith(true)
    })

    it('should set analyzing to false on completion', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      expect(mockSetAnalyzing).toHaveBeenLastCalledWith(false)
    })

    it('should add analysis with study UID', async () => {
      const { result } = renderHook(() => useAiOperations(defaultOptions))

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      expect(mockAddAnalysis).toHaveBeenCalledWith(
        expect.objectContaining({
          studyInstanceUID: mockStudy.studyInstanceUID,
        })
      )
    })
  })

  describe('hook stability', () => {
    it('should return stable function references', () => {
      const { result, rerender } = renderHook(() => useAiOperations(defaultOptions))
      const firstHandleAiDetection = result.current.handleAiDetection
      const firstHandleAiAnalysis = result.current.handleAiAnalysis

      rerender()

      expect(result.current.handleAiDetection).toBe(firstHandleAiDetection)
      expect(result.current.handleAiAnalysis).toBe(firstHandleAiAnalysis)
    })

    it('should update when dependencies change', () => {
      const { result, rerender } = renderHook(
        ({ instance }) => useAiOperations({ ...defaultOptions, currentInstance: instance }),
        { initialProps: { instance: mockInstance } }
      )

      const firstHandleAiDetection = result.current.handleAiDetection
      const newInstance = createMockInstance()

      rerender({ instance: newInstance })

      // Function reference should change when dependencies change
      expect(result.current.handleAiDetection).not.toBe(firstHandleAiDetection)
    })
  })

  describe('guards and validation', () => {
    it('should not run detection when already detecting', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, isDetecting: true })
      )

      await act(async () => {
        await result.current.handleAiDetection()
      })

      // Should not delete annotations or call setDetecting
      expect(mockDeleteAnnotationsForInstance).not.toHaveBeenCalled()
      expect(mockSetDetecting).not.toHaveBeenCalled()
    })

    it('should not run analysis when already analyzing', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, isAnalyzing: true })
      )

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      // Should not call setAnalyzing or addAnalysis
      expect(mockSetAnalyzing).not.toHaveBeenCalled()
      expect(mockAddAnalysis).not.toHaveBeenCalled()
    })

    it('should not run analysis without study UID', async () => {
      const { result } = renderHook(() =>
        useAiOperations({ ...defaultOptions, currentStudy: null })
      )

      await act(async () => {
        await result.current.handleAiAnalysis()
      })

      // Should not proceed with analysis
      expect(mockSetAnalyzing).not.toHaveBeenCalled()
    })
  })
})
